// Authors:
// Balazs Bencze <balazs.bencze@geogebra.org>,
// Zbynek Konecny <zbynek@geogebra.org>,
// Zoltan Kovacs <zoltan@geogebra.org> and
// Agoston Suto <suto.agoston@yahoo.com>.
// Based on Bernard Parisse's original Makefiles and other scripts.


plugins {
    id 'org.hidetake.ssh' version '2.10.1'
    id 'visual-studio'
    id 'cpp'
    id 'de.undercouch.download' version '3.1.1'
    id 'maven-publish'
}


apply from: 'repositories.gradle'

project.setDescription('Giac CAS for GeoGebra')


/*
 * For the impatient: Run "./gradlew downloadEmsdk installEmsdk activateEmsdk createGiacWasmJs"
 * to compile the WebAssembly version via Emscripten.
 *
 * Emscripten related settings.
 *
 * Currently we use version 2.0.16, other versions may not work correctly,
 * or may have problems in some Giac commands and results. By default, 2.0.16 will be used.
 *
 * 1. You will need to download the correct toolchain version by running the tasks downloadEmsdk,
 *    then optionally set EMSCRIPTEN_VERSION=tag-2.0.16, and run the task installEmsdk.
 *    (Always take care of using the correct emscripten version and also the appropriate clang compiler,
 *    otherwise you may encounter extremely strange problems on compilation time or runtime.
 *    Newer emscripten versions usually do sanity checks during the compilation and inform you
 *    about any issues.) This step may take a while since clang may be recompiled from source.
 *    (You may need additional tools to compile it including cmake.)
 *
 * 2. Hopefully you have the correct versions of GMP and MPFR in src/giac.js/prebuilt/. If not, you
 *    need to compile the correct version. The provided tasks may compile an incorrect version for
 *    2.0.16, but it should work for the older ones. The related tasks are: emConfigureGmp,
 *    emMakeGmp, emConfigureMpfr, emMakeMpfr. (The correct GMP and MPFR versions can be tested
 *    by entering some big integer/real computations.) First you may need to set some environmental
 *    variables or hardcoded script variables manually. FIXME
 *    The compilation can be influenced by using the environmental variable EXT_GMPMPFR (local/emgiac).
 *    Luckily, the current prebuilt files should work properly with 2.0.16.
 *
 * 3. Run the createGiacWasmJs task. It will recompile all C++ files and then re-link the library.
 *    It can be fine-tuned by using the EMSCRIPTEN_VERSION environmental variables
 *    (but usually not required to use them). That, is you usually need the following command line:
 *
 *    $ EMSCRIPTEN_VERSION=tag-2.0.16 ../gradlew clean activateEmsdk createGiacWasmJs
 *
 *    This command line will work only after you already ran downloadEmsdk and installEmsdk
 *    (as described above).
 */

// FIXME: Some of these settings are hardcoded at the moment, they need to be more general.
def externalSourceDir = "/home/autotest/gmp+mpfr-llvm"
// You may need to download and unzip following packages:
def gmpSourceDir = "$externalSourceDir/gmp-6.0.0"
def mpfrSourceDir = "$externalSourceDir/mpfr-3.1.2"
def emgiacSourceDir = "$externalSourceDir/emgiac"

def jsPrebuiltDir = "src/giac.js/prebuilt"
def LlvmMpfrA = "$jsPrebuiltDir/libmpfr.a"
def LlvmGmpA = "$jsPrebuiltDir/libgmp.a"
if (System.env['EXT_GMPMPFR'] != null && System.env['EXT_GMPMPFR'] == "local") {
    LlvmMpfrA = "$mpfrSourceDir/src/.libs/libmpfr.a"
    LlvmGmpA = "$gmpSourceDir/.libs/libgmp.a"
}
if (System.env['EXT_GMPMPFR'] != null && System.env['EXT_GMPMPFR'] == "emgiac") {
    LlvmMpfrA = "$emgiacSourceDir/giac/libmpfr.a"
    LlvmGmpA = "$emgiacSourceDir/giac/libgmp.a"
}

def emsdkUrlFolder = 'https://s3.amazonaws.com/mozilla-games/emscripten/releases'
def emsdkTgzFile = 'emsdk-portable.tar.gz'
def emsdkDir = file('emsdk')
def emsdkRunDir = file("$emsdkDir")

def emscriptenVersion = 'tag-2.0.16'
if (System.env['EMSCRIPTEN_VERSION'] != null) {
    emscriptenVersion = System.env['EMSCRIPTEN_VERSION'];
}
def emscriptenDir = file("$emsdkRunDir/emscripten/latest")

def emccCommand = "${emscriptenDir}/emcc"

// End of emscripten related settings. Huh.
def java_home = org.gradle.internal.jvm.Jvm.current().javaHome
ext.ggrev = project.findProperty("revision") ?: "SNAPSHOT"
def giacVersion = '"1.2.4-' + ggrev + '"'
println giacVersion
import org.apache.tools.ant.taskdefs.condition.Os
def isMac = Os.isFamily(Os.FAMILY_MAC)

def exec_(String... script) {
    if (!Os.isFamily(Os.FAMILY_MAC)) {
        return ""
    }
    def retVal
    exec {
        commandLine script
        standardOutput = new ByteArrayOutputStream()
        retVal = {
            standardOutput.toString().trim()
        }
    }
    return retVal()
}

def gccBin = exec_("xcrun", "--sdk", "macosx", "--find", "gcc")
def gccPath = "/usr/bin"
if (gccBin.length() > 0) {
    gccPath = gccBin.substring(0, gccBin.lastIndexOf("/"))
}
def clangMacosxBin = exec_("xcrun", "--sdk", "macosx", "--find", "clang")
ext.clangMacosxPath = "/usr/bin"
if (clangMacosxBin.length() > 0) {
    ext.clangMacosxPath = clangMacosxBin.substring(0, clangMacosxBin.lastIndexOf("/"))
}
def clangIosBin = exec_("xcrun", "--sdk", "iphoneos", "--find", "clang++")
ext.clangIosPath = "/usr/bin"
if (clangIosBin.length() > 0) {
    ext.clangIosPath = clangIosBin.substring(0, clangIosBin.lastIndexOf("/"))
}
def clangIphonesimulatorBin = exec_("xcrun", "--sdk", "iphonesimulator", "--find", "clang++")
ext.clangIphonesimulatorPath = "/usr/bin"
if (clangIphonesimulatorBin.length() > 0) {
    ext.clangIphonesimulatorPath = clangIphonesimulatorBin.substring(0, clangIphonesimulatorBin.lastIndexOf("/"))
}

def macosSdk = exec_("xcrun", "--sdk", "macosx", "--show-sdk-path")
def iphoneosSdk = exec_("xcrun", "--sdk", "iphoneos", "--show-sdk-path")
def iphonesimulatorSdk = exec_("xcrun", "--sdk", "iphonesimulator", "--show-sdk-path")
def iphoneosPlatform = exec_("xcrun", "--sdk", "iphoneos", "--show-sdk-platform-path")
def minIosVersion = '9.0'

def simulatorPostfix = "-simulator"
def catalystPostfix = "-macabi"
def iosTarget(arch, minIosVersion, postfix = "") {
    return "${arch}-apple-ios${minIosVersion}${postfix}";
}

def iosClangCompilerArgs(args, sdk, arch, minIosVersion, target) {
    appleCompilerArgs(args)
    for (int i = args.size() - 1; i >= 0; i--) {
        if (args[i].equals("-nostdinc")) {
            args.remove(i);
        }
    }
    args << "-isysroot"
    args << "${sdk}"
    args << "-target"
    args << target
    args << "-miphoneos-version-min=${minIosVersion}"
    args << "-std=gnu++98"
    args << "-stdlib=libc++"
    args << "-fembed-bitcode"
    args << "-O0"
}

def giacCommonDefines(cppCompiler) {
    cppCompiler.define "GIAC_GGB"
    cppCompiler.define "IN_GIAC"
    cppCompiler.define "GIAC_GENERIC_CONSTANTS"
    cppCompiler.define "HAVE_UNISTD_H"
    cppCompiler.define "HAVE_LIBPTHREAD"
    cppCompiler.define "HAVE_SYSCONF"
    cppCompiler.define "HAVE_NO_HOME_DIRECTORY"
    cppCompiler.define "VERSION", '"dummy"' // will be overwritten later, see below
    cppCompiler.define "TIMEOUT"
    cppCompiler.define 'HAVE_SYS_TIMES_H'
    cppCompiler.define 'HAVE_SYS_TIME_H'
}

def giacIosDefines(cppCompiler) {
    cppCompiler.define 'APPLE_SMART'
    cppCompiler.define 'NO_GETTEXT'
    cppCompiler.define 'NO_SCANDIR'
    cppCompiler.define 'OSX_10_9_CXX'
    cppCompiler.define 'HAVE_CONFIG_H'
    cppCompiler.define '_IOS_FIX_'
}

def giacSpecificSettings(cppCompiler, linker, targetPlatform) {
    cppCompiler.define 'IN_GIAC'
    cppCompiler.define 'GIAC_GENERIC_CONSTANTS'
    cppCompiler.define 'HAVE_CONFIG_H'
    cppCompiler.define 'GIAC_GGB'
    cppCompiler.define 'TIMEOUT'
    cppCompiler.args '-fexceptions'
    cppCompiler.args '-O2' // standard optimization (default)
    cppCompiler.args '-I.'

    // Architecture based settings:
    if (targetPlatform.architecture.name == 'i386') {
        cppCompiler.define 'SMARTPTR64'
        cppCompiler.define 'SIZEOF_LONG', '8'
    } else {
        cppCompiler.define 'SIZEOF_LONG', '4'
    }
    // OS based settings:
    if (targetPlatform.operatingSystem.name == 'windows') {
        cppCompiler.define 'GIAC_MPQS'
        cppCompiler.define '__MINGW_H'
        cppCompiler.define 'MINGW32'
        cppCompiler.define 'HAVE_NO_SYS_TIMES_H'
        cppCompiler.define 'HAVE_NO_SYS_RESOURCE_WAIT_H'
        cppCompiler.define 'HAVE_NO_PWD_H'
        cppCompiler.define 'HAVE_NO_CWD'
        cppCompiler.define 'NO_CLOCK'
        cppCompiler.define 'usleep',''
        cppCompiler.define 'YY_NO_UNISTD_H'

        cppCompiler.args '-I', file('src/jni/jdkHeaders/win32').toString()
        // Insert prebuilt libraries
        linker.args '-Wl,--add-stdcall-alias'
        linker.args '-s' // stripping

        // Add libgcc and libstdc++ statically
        linker.args '-static-libgcc'
        linker.args '-static-libstdc++'
        // Statically link libpthread
        // linker.args '-Wl,-Bstatic', '-lstdc++', '-lpthread'
        // Or even better, everything
        linker.args '-static'
    }

    if (targetPlatform.operatingSystem.name == 'linux') {
        if (targetPlatform.architecture.name == 'arm-v7') {
            cppCompiler.define 'HAVE_GETTEXT'
            linker.args '-lstdc++'
        }


        cppCompiler.define 'HAVE_UNISTD_H'

        cppCompiler.args '-I', file('src/jni/jdkHeaders/linux').toString()
        cppCompiler.args '-fno-strict-aliasing' // maybe not needed
        cppCompiler.args '-DPIC' // maybe not needed
        cppCompiler.args '-fpermissive'

        linker.args '-s' // stripping

        // Add libgcc and libstdc++ statically
        linker.args '-static-libgcc'
        linker.args '-static-libstdc++'

    }
    if (targetPlatform.operatingSystem.name == 'android') {
        cppCompiler.define 'HAVE_UNISTD_H'
        cppCompiler.define 'NO_BSD'

        cppCompiler.args '-I', file('src/jni/jdkHeaders/linux').toString()
        // overwrite standard headers with custom android headers
        cppCompiler.args '-iquote', file('src/giac/headers/android').toString()
        cppCompiler.args '-fno-strict-aliasing' // maybe not needed
        cppCompiler.args '-DPIC' // maybe not needed
        cppCompiler.args '-fPIC' // android 6.0 doesn't load libraries which have text relocations

        linker.args '-s' // stripping
    }

    if (targetPlatform.operatingSystem.name == 'osx') {
        cppCompiler.define 'HAVE_UNISTD_H'
        cppCompiler.define 'APPLE_SMART'
        cppCompiler.define 'NO_SCANDIR'
        cppCompiler.define 'HAVE_SYS_TIMES_H'
        cppCompiler.define 'HAVE_SYS_TIME_H'
        cppCompiler.args '-stdlib=libc++'

        linker.args '-Wl,-search_paths_first'
        if (targetPlatform.architecture.name == 'x86-64') {
            linker.args '-L', file('src/jni/prebuilt/osx/x86-64').toString()
        } else {
            linker.args '-L', file('src/jni/prebuilt/osx/arm64').toString()
        }

        linker.args '-stdlib=libc++', '-lc++'
        linker.args '-lgmp', '-lmpfr', '-lpthread', '-dynamiclib'
        linker.args '-framework', 'Accelerate'
        linker.args '-framework', 'CoreFoundation'
    }
}

def appleCompilerArgs(args) {
    // Gradle is including "sensible default" include paths that are based on the host OS that break cross-compilation
    // The only fix as I see it is to clear out all includes except the ones that point to protos
    // SEE https://github.com/gradle/gradle-native/issues/614
    // isystem args also removed, see https://github.com/gradle/gradle-native/issues/583
    for (int i = args.size() - 1; i >= 0; i--) {
        if ((args[i].equals("-I") || args[i].equals("-isystem")) && !args[i+1].startsWith("$rootDir")) {
            args.remove(i + 1);
            args.remove(i);
        }
    }
}

def macosCompilerArgs(args, target) {
    appleCompilerArgs(args)
    if (target != null) {
        args << '-target'
        args << target
    }
    args << '-mmacosx-version-min=10.7'
    args << "-isysroot"
    args << '/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk'
    args << '-stdlib=libc++'
    args << '-lc++'
    args << '-I/System/Library/Frameworks/CoreFoundation.framework/Headers'
    args << '-I'
    args << file('src/jni/jdkHeaders/darwin').toString()
}

model {
    repositories {
        libs(PrebuiltLibraries) {
            mpfr {
                binaries.withType(StaticLibraryBinary) {
                    def arch = targetPlatform.architecture.name
                    def os = targetPlatform.operatingSystem.name
                    staticLibraryFile = file("src/jni/prebuilt/$os/$arch/libmpfr.a")
                }
            }
            gmp {
                binaries.withType(StaticLibraryBinary) {
                    def arch = targetPlatform.architecture.name
                    def os = targetPlatform.operatingSystem.name
                    staticLibraryFile = file("src/jni/prebuilt/$os/$arch/libgmp.a")
                }
            }
        }
    }

    platforms {
        win32 {
            architecture 'i386'
            operatingSystem 'windows'
        }
        win64 {
            architecture 'x64'
            operatingSystem 'windows'
        }
        linux32 { // this will be fixed in Gradle 2.4 (-> linux32)
            architecture 'i386'
            operatingSystem 'linux'
        }
        linux64 {
            architecture 'x64'
            operatingSystem 'linux'
        }
        rpi {
            architecture 'arm'
            operatingSystem 'linux'
        }
        osx_amd64 {
            architecture 'amd64'
            operatingSystem 'osx'
        }
        osx_arm64 {
            architecture 'arm64'
            operatingSystem 'osx'
        }
        androideabi {
            architecture 'arm'
            operatingSystem 'android'
        }
        androidx86 {
            architecture 'x86'
            operatingSystem 'android'
        }
        androidx86_64 {
            architecture 'x86_64'
            operatingSystem 'android'
        }
        androidarm64 {
            architecture 'arm64'
            operatingSystem 'android'
        }
        ios_arm64 {
            architecture 'arm64'
            operatingSystem 'ios'
        }
        iphonesimulator_x86_64 {
            architecture 'x86_64'
            operatingSystem 'iphonesimulator'
        }
        iphonesimulator_arm64 {
            architecture 'x86_64'
            operatingSystem 'iphonesimulator'
        }
        maccatalyst_x86_64 {
            architecture 'x86_64'
            operatingSystem 'maccatalyst'   
        }
        maccatalyst_arm64 {
            architecture 'arm64'
            operatingSystem 'maccatalyst'   
        }
    }

    toolChains {
        mingw(Gcc) {
            target('win32') {
                cppCompiler.executable 'i686-w64-mingw32-g++'
                linker.executable 'i686-w64-mingw32-g++'
            }
            target('win64') {
                cppCompiler.executable 'x86_64-w64-mingw32-g++'
                linker.executable 'x86_64-w64-mingw32-g++'
            }
        }
        gcc(Gcc) {
            target('rpi') {
                cppCompiler.executable 'gcc'
                linker.executable 'gcc'
            }
        }
        clang(Clang) {
            target('osx_amd64') {
                cppCompiler.executable 'clang'
                linker.executable 'gcc'
                path gccPath, clangMacosxPath

                cppCompiler.withArguments { args ->
                    macosCompilerArgs(args, null)
                }
            }
            target('osx_arm64') {
                cppCompiler.executable 'clang'
                linker.executable 'gcc'
                path gccPath, clangMacosxPath

                cppCompiler.withArguments { args ->
                    macosCompilerArgs(args, 'arm64-apple-macos11')
                }
                linker.withArguments { args ->
                    args << '--target=arm64-apple-macos11'
                }
            }
            target('ios_armv7') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, iphoneosSdk, "armv7", minIosVersion, iosTarget("armv7", minIosVersion))
                }
                path clangIosPath
            }
            target('ios_arm64') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, iphoneosSdk, "arm64", minIosVersion, iosTarget("arm64", minIosVersion))
                }
                path clangIosPath
            }
            target('iphonesimulator_i386') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, iphonesimulatorSdk, "i386", minIosVersion, iosTarget("i386", minIosVersion, simulatorPostfix))
                }
                path clangIphonesimulatorPath
            }
            target('iphonesimulator_x86_64') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, iphonesimulatorSdk, "x86_64", minIosVersion, iosTarget("x86_64", minIosVersion, simulatorPostfix))
                }
                path clangIphonesimulatorPath
            }
            target('iphonesimulator_arm64') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, iphonesimulatorSdk, "arm64", minIosVersion, iosTarget("arm64", minIosVersion, simulatorPostfix))
                }
                path clangIphonesimulatorPath
            }
            target('maccatalyst_x86_64') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, macosSdk, "x86_64", minIosVersion, iosTarget("x86_64", "13.0", catalystPostfix))
                }
                path clangMacosxPath

            }
            target('maccatalyst_arm64') {
                cppCompiler.executable 'clang'
                cppCompiler.withArguments { args ->
                    iosClangCompilerArgs(args, macosSdk, "arm64", minIosVersion, iosTarget("arm64", "13.0", catalystPostfix))
                }
                path clangMacosxPath
            }

        }
        // Note: Make sure manually that these executables are on the PATH.
        android(Gcc) {
            target('androideabi') {
                cppCompiler.executable 'arm-linux-androideabi-g++'
                linker.executable 'arm-linux-androideabi-g++'
            }
            target('androidx86') {
                cppCompiler.executable 'i686-linux-android-g++'
                linker.executable 'i686-linux-android-g++'
            }
            target('androidx86_64') {
                cppCompiler.executable 'x86_64-linux-android-g++'
                linker.executable 'x86_64-linux-android-g++'
            }
            target('androidarm64') {
                cppCompiler.executable 'aarch64-linux-android-g++'
                linker.executable 'aarch64-linux-android-g++'
            }
        }
    }

    components {
        // giac static libary
        giac(NativeLibrarySpec) {
            targetPlatform 'linux32'
            targetPlatform 'linux64'
            targetPlatform 'ios_arm64'
            targetPlatform 'iphonesimulator_x86_64'
            targetPlatform 'iphonesimulator_arm64'
            targetPlatform 'maccatalyst_x86_64'
            targetPlatform 'maccatalyst_arm64'
            if (isMac) {
                targetPlatform 'osx_amd64'
                targetPlatform 'osx_arm64'
            }
            targetPlatform 'rpi'

            binaries.all {
                giacCommonDefines(cppCompiler)
                giacSpecificSettings(cppCompiler, linker, targetPlatform)
                if (targetPlatform.operatingSystem.name == 'ios' 
                    || targetPlatform.operatingSystem.name == 'iphonesimulator'
                    || targetPlatform.operatingSystem.name == 'maccatalyst') {
                    giacIosDefines(cppCompiler)
                    if (targetPlatform.architecture.name == 'arm-v8') {
                        cppCompiler.define 'x86_64'
                    }
                } else if (targetPlatform.operatingSystem.name == 'osx') {
                    cppCompiler.define 'NO_GETTEXT'
                }
                cppCompiler.args '-fpermissive' // needed for recent G++
            }
        }

        simpleInterface(NativeLibrarySpec) {
            targetPlatform 'ios_arm64'
            targetPlatform 'iphonesimulator_x86_64'
            targetPlatform 'iphonesimulator_arm64'
            targetPlatform 'maccatalyst_x86_64'
            targetPlatform 'maccatalyst_arm64'

            binaries.all {
                lib library: 'giac', linkage: 'static'
                giacCommonDefines(cppCompiler)
                if (targetPlatform.operatingSystem.name == 'ios'
                    || targetPlatform.operatingSystem.name == 'iphonesimulator') {
                    giacIosDefines(cppCompiler)
                    if (targetPlatform.architecture.name == 'arm-v8') {
                        cppCompiler.define 'x86_64'
                    }
                }
            }
        }

        minigiac(NativeExecutableSpec) {
            targetPlatform 'linux32'
            targetPlatform 'linux64'

            binaries.all {
                lib library: 'giac', linkage: 'static'
                linker.args '-lgmp', '-lmpfr', '-lpthread'
                cppCompiler.define 'GIAC_GGB'
                cppCompiler.define 'IN_GIAC'
                cppCompiler.define 'GIAC_GENERIC_CONSTANTS'
                cppCompiler.define 'HAVE_CONFIG_H'
                cppCompiler.define 'HAVE_UNISTD_H'
                cppCompiler.define 'HAVE_SYS_TIMES_H'
                cppCompiler.define 'HAVE_SYS_TIME_H'
                cppCompiler.define 'VERSION', giacVersion
                cppCompiler.args '-fpermissive' // needed for recent G++
            }
            sources.all {
                source {
                    srcDirs 'src/giac/cpp', 'src/minigiac/cpp'
                }
            }
        }

        javagiac(NativeLibrarySpec) {
            targetPlatform 'win32'
            targetPlatform 'win64'
            targetPlatform 'linux32' // this will be fixed in Gradle 2.4 (-> linux32)
            targetPlatform 'linux64'
            if (isMac) {
                targetPlatform 'osx_amd64'
            }
            targetPlatform 'androideabi'
            targetPlatform 'androidx86'
            targetPlatform 'androidx86_64'
            targetPlatform 'androidarm64'
            targetPlatform 'rpi'

            sources.cpp {
                source {
                    srcDirs 'src/giac/cpp', 'src/jni/cpp'
                }
                exportedHeaders {
                    srcDirs 'src/giac/headers', 'src/jni/jdkHeaders'
                }
                lib library: 'mpfr', linkage: 'static'
                lib library: 'gmp', linkage: 'static'
            }

            binaries.withType(SharedLibraryBinarySpec) {
                giacSpecificSettings(cppCompiler, linker, targetPlatform)
                linker.args "-I${java_home}/include", "-Isrc/jni/jdkHeaders"

                if (targetPlatform.operatingSystem.name == 'osx') {
                    cppCompiler.define 'gettext', ''
                    def path = 'build/binaries/javagiacSharedLibrary/osx_amd64/'
                    mkdir(path)
                    linker.args '-o', "$path/libjavagiac.jnilib" // TODO: find a more elegant way
                }
            }
        }

        GeoGebraCASDemo(NativeExecutableSpec) {
            if (isMac) {
                targetPlatform 'osx_amd64'
                targetPlatform 'osx_arm64'
            }

            binaries.all {
                lib library: 'GeoGebraCAS', linkage: 'shared'
                if (targetPlatform.operatingSystem.name == 'osx') {
                    cppCompiler.args '-stdlib=libc++'
                    linker.args '-stdlib=libc++', '-lc++'
                    if (targetPlatform.architecture.name == 'i386') {
                        cppCompiler.args '-m32'
                        linker.args '-m32'
                    } else if (targetPlatform.architecture.name == 'arm-v8') {
                        linker.args '-target', 'arm64-apple-macos11'
                    }
                } else {
                    cppCompiler.args '/EHsc'
                    if (project.hasProperty("debugsymbols")) {
                        linker.args "/DEBUG"
                    }
                }
            }
            sources.all {
                lib library: 'GeoGebraCAS', linkage: 'shared' // maybe necessary only on Windows
                source {
                    srcDirs 'src/GeoGebraCAS-demo/cpp'
                }
                exportedHeaders {
                    srcDirs 'src/GeoGebraCAS/headers'
                }
            }
        }

        GeoGebraCAS(NativeLibrarySpec) {
            if (isMac) {
                targetPlatform 'osx_amd64'
                targetPlatform 'osx_arm64'
            }

            sources.cpp {
                source {
                    srcDirs 'src/GeoGebraCAS/cpp'
                }
                exportedHeaders {
                    srcDirs 'src/GeoGebraCAS/headers', "src/giac/headers"
                }
                if (System.getProperty("os.name") != "Mac OS X") {
                    lib library: 'gmp', linkage: 'shared'
                    lib library: 'mpfr', linkage: 'shared'
                }
                lib library: 'giac', linkage: 'static'
            }

            binaries.withType(SharedLibraryBinarySpec) {
                if (targetPlatform.operatingSystem.name == 'osx') {
                    cppCompiler.args '-stdlib=libc++'
                    linker.args '-stdlib=libc++', '-lc++'
                    linker.args '-lgmp', '-lmpfr', '-lpthread'
                    if (targetPlatform.architecture.name == 'x86-64') {
                        linker.args '-L', file('src/jni/prebuilt/osx/x86-64').toString(), '-dynamiclib'
                    } else if (targetPlatform.architecture.name == 'arm-v8') {
                        linker.args '-L', file('src/jni/prebuilt/osx/arm64').toString(), '-dynamiclib'
                    } else {
                        throw new GradleException("Unknown architecture ${targetPlatform.architecture.name}")
                    }
                }
            }
        }
    }
}

def lipo(name, output, clangPath, String... libraries) {
    def args = ["${clangPath}/lipo"] + libraries.flatten() + ["-create", "-output", "${output}/${name}.a"]
    mkdir("${output}")
    exec_(args as String[])
}

def mergeLibraries(name, output, clangPath, String... libraries) {
    def args = ["${clangPath}/libtool", "-static", "-o", "${output}/${name}.a"]
    args.addAll(libraries)
    mkdir("${output}")
    exec_(args as String[])
}

task simpleInterfaceIosStaticLibrary(dependsOn: [
    'simpleInterfaceIos_arm64StaticLibrary', 
    'simpleInterfaceIphonesimulator_x86_64StaticLibrary',
    'simpleInterfaceIphonesimulator_arm64StaticLibrary',
    'simpleInterfaceMaccatalyst_x86_64StaticLibrary',
    'simpleInterfaceMaccatalyst_arm64StaticLibrary'
])

task giacIosStaticLibrary(dependsOn: [
    'giacIos_arm64StaticLibrary', 
    'giacIphonesimulator_x86_64StaticLibrary',
    'giacIphonesimulator_arm64StaticLibrary',
    'giacMaccatalyst_x86_64StaticLibrary',
    'giacMaccatalyst_arm64StaticLibrary'
])

task configBundle(type: Exec) {
    executable 'bundle'
    args 'config', 'set', 'path', './.gems'
    workingDir rootDir
}

task installGems(type: Exec, dependsOn: 'configBundle') {
    executable 'bundle'
    args 'install'
    workingDir rootDir
}

task createFatIosStaticLibrary(dependsOn: ['simpleInterfaceIosStaticLibrary', 'giacIosStaticLibrary']) {
    doLast {
        def output = "${buildDir}/libs/merged"
        ["arm64"].each {
            mergeLibraries("Giac", "${output}/ios_${it}", clangIosPath,
                "${buildDir}/libs/giac/static/ios_${it}/libgiac.a", 
                "${buildDir}/libs/simpleInterface/static/ios_${it}/libSimpleInterface.a", 
                "src/jni/prebuilt/ios/${it}/libgmp.a", 
                "src/jni/prebuilt/ios/${it}/libmpfr.a")
        }
        ["arm64", "x86_64"].each {
            mergeLibraries("Giac", "${output}/iphonesimulator_${it}", clangIphonesimulatorPath,
                "${buildDir}/libs/giac/static/iphonesimulator_${it}/libgiac.a", 
                "${buildDir}/libs/simpleInterface/static/iphonesimulator_${it}/libSimpleInterface.a", 
                "src/jni/prebuilt/iphonesimulator/${it}/libgmp.a", 
                "src/jni/prebuilt/iphonesimulator/${it}/libmpfr.a")
        }
        ["arm64", "x86_64"].each {
            mergeLibraries("Giac", "${output}/maccatalyst_${it}", clangIphonesimulatorPath,
                "${buildDir}/libs/giac/static/maccatalyst_${it}/libgiac.a", 
                "${buildDir}/libs/simpleInterface/static/maccatalyst_${it}/libSimpleInterface.a", 
                "src/jni/prebuilt/maccatalyst/${it}/libgmp.a", 
                "src/jni/prebuilt/maccatalyst/${it}/libmpfr.a")
        }

        lipo("Giac", "${output}/ios", clangIosPath, "${output}/ios_arm64/Giac.a")
        lipo("Giac", "${output}/iphonesimulator", clangIphonesimulatorPath,
            "${output}/iphonesimulator_arm64/Giac.a", 
            "${output}/iphonesimulator_x86_64/Giac.a")
        lipo("Giac", "${output}/maccatalyst", clangIphonesimulatorPath,
            "${output}/maccatalyst_arm64/Giac.a", 
            "${output}/maccatalyst_x86_64/Giac.a")
    }
}

task createIosFramework(dependsOn: createFatIosStaticLibrary, type: Copy) {
    description "Creates iOS framework"
    from("${buildDir}/libs/merged/ios") {
        include "Giac.a"
        rename "Giac.a", "Giac"
        into "Giac.framework"
    }
    from("src/simpleInterface/headers") {
        include "*.hpp"
        into "Giac.framework/Headers"
    }
    from("src/simpleInterface/framework") {
        include "Info.plist"
        into "Giac.framework/Resources"
    }

    destinationDir = file("${buildDir}/libs/framework/ios")
}

task createIphonesimulatorFramework(dependsOn: createFatIosStaticLibrary, type: Copy) {
    description "Creates iPhone Simlator framework"
    from("${buildDir}/libs/merged/iphonesimulator") {
        include "Giac.a"
        rename "Giac.a", "Giac"
        into "Giac.framework"
    }
    from("src/simpleInterface/headers") {
        include "*.hpp"
        into "Giac.framework/Headers"
    }
    from("src/simpleInterface/framework") {
        include "framework.plist"
        rename "framework.plist", "Info.plist"
        into "Giac.framework/Resources"
    }

    destinationDir = file("${buildDir}/libs/framework/iphonesimulator")
}

task createMaccatalystFramework(dependsOn: createFatIosStaticLibrary, type: Copy) {
    description "Creates Mac Catalyst framework"
    from("${buildDir}/libs/merged/maccatalyst") {
        include "Giac.a"
        rename "Giac.a", "Giac"
        into "Giac.framework"
    }
    from("src/simpleInterface/headers") {
        include "*.hpp"
        into "Giac.framework/Headers"
    }

    destinationDir = file("${buildDir}/libs/framework/maccatalyst")
}


task createIosXcframework(dependsOn: [createIosFramework, createIphonesimulatorFramework, createMaccatalystFramework], type: Copy) {
    description "Creates XCFramework"
    from("${buildDir}/libs/framework/iphonesimulator") {
        into "ios-arm64_x86_64-simulator"
    }
    from("${buildDir}/libs/framework/ios") {
        into "ios-arm64"
    }
    from("${buildDir}/libs/framework/maccatalyst") {
        into "ios-arm64_x86_64-maccatalyst"
    }
    from("src/simpleInterface/framework") {
        include "xcframework.plist"
        rename "xcframework.plist", "Info.plist"
    }

    destinationDir = file("${buildDir}/libs/framework/Giac.xcframework")
}

task createPodspec() {
    inputs.file "src/simpleInterface/pod/Giac.podspec"
    inputs.property "version", ggrev
    outputs.file "${buildDir}/cocoapods/Giac.podspec"
    doLast {
        def posdpec = inputs.files.singleFile
        def engine = new groovy.text.SimpleTemplateEngine()
        def binding = [version: ggrev]
        def template = engine.createTemplate(posdpec).make(binding)
        def outputFile = outputs.files.singleFile
        outputFile.parentFile.mkdirs()
        outputFile.write template.toString()
    }
}

task cocoapodsZip(dependsOn: createIosXcframework, type: Zip) {
    baseName 'Giac'
    from ("${buildDir}/libs/framework/Giac.xcframework") {
        into "Frameworks/Giac.xcframework"
    }
    destinationDir = file("${buildDir}/cocoapods/")
}

task publishPodspec(dependsOn: ['installGems', 'createPodspec', 'publishMavenZipPublicationToMavenRepository'], type: Exec) {
    commandLine 'bundle', 'exec', 'pod', 'repo', 'push', 'geogebra-specs', "${buildDir}/cocoapods/Giac.podspec", '--allow-warnings'
}

task installMinigiacExecutable (dependsOn: 'installMinigiacLinux64Executable')

task installNodegiacExecutable (type: Exec) {
    // FIXME: dependencies should be set
    description 'Installs the nodegiac executable.'
    commandLine 'npm', 'install'
}

task testMinigiacExecutable (dependsOn: 'installMinigiacExecutable', type: Exec) {
    description 'Tests the minigiac executable.'
    workingDir 'src/test'
    commandLine './regression', '-r'
}

task testNodegiacExecutable (dependsOn: 'installNodegiacExecutable', type: Exec) {
    description 'Tests the nodegiac executable.'
    workingDir 'src/test'
    commandLine './regression', '-r', '-n'
}

task testExecutables (dependsOn: ['testNodegiacExecutable', 'testMinigiacExecutable'])


task androidCopyEabiLibjavagiacSo (dependsOn: 'javagiacAndroideabiSharedLibrary', type: Copy) {
    description 'Copies libjavagiac.so files to the src/android folder.'
    from 'build/libs/javagiac/shared/androideabi'
    into 'giac-android/src/main/jniLibs/armeabi-v7a'
    include ('libjavagiac.so')
}

task androidCopyX86LibjavagiacSo (dependsOn: 'javagiacAndroidx86SharedLibrary', type: Copy) {
    description 'Copies libjavagiac.so files to the src/android folder.'
    from 'build/libs/javagiac/shared/androidx86'
    into 'giac-android/src/main/jniLibs/x86'
    include ('libjavagiac.so')
}

task androidCopyX86_64LibjavagiacSo (dependsOn: 'javagiacAndroidx86_64SharedLibrary', type: Copy) {
    description 'Copies libjavagiac.so files to the src/android folder.'
    from 'build/libs/javagiac/shared/androidx86_64'
    into 'giac-android/src/main/jniLibs/x86_64'
    include ('libjavagiac.so')
}

task androidCopyArm64LibjavagiacSo (dependsOn: 'javagiacAndroidarm64SharedLibrary', type: Copy) {
    description 'Copies libjavagiac.so files to the src/android folder.'
    from 'build/libs/javagiac/shared/androidarm64'
    into 'giac-android/src/main/jniLibs/arm64-v8a'
    include ('libjavagiac.so')
}


task run (dependsOn: 'installMinigiacExecutable', type: Exec) {
    description "Runs Giac's minigiac terminal"
    commandLine "build/install/minigiac/linux64/minigiac" // FIXME, this is hardcoded
    standardInput = System.in
}

def objDir = "build/objs/giac-wasm.js"
def binaryJsDir = "build/binaries/giacggb.wasm"

tasks.addRule("Pattern: emccCompileWasm_<FILE>Cc: Compile <FILE>.cc into <FILE>.o.") { String taskName ->
    if ((taskName.startsWith('emccCompileWasm')) && (taskName.endsWith('Cc'))) {
        def basename = (taskName - 'Cc').substring('emccCompileWasm_'.length())
        task(taskName) {
            mustRunAfter 'activateEmsdk'
            def input = "src/giac/cpp/${basename}.cc"
            inputs.file input
            def output = objDir + "/${basename}.o"
            outputs.file output
            doLast {
                file(objDir+"/").mkdirs()
                exec {
                    // Be very careful when changing this: config.h also contains some entries!
                    def specialOptions = ''
                    def commandline = emccCommand
                    commandline += ' -DIN_GIAC -DGIAC_GENERIC_CONSTANTS -DHAVE_CONFIG_H -DNO_STDEXCEPT -fno-exceptions' // from old Makefile
                    commandline += ' -DVERSION=' + giacVersion
                    commandline += " -Dgammaf=tgammaf -s ALLOW_MEMORY_GROWTH=1"
                    commandline += " -s WASM=1 -s NO_EXIT_RUNTIME=1"
                    commandline += " -s PRECISE_I64_MATH=1 -Oz" // new setting
                    commandline += " -DHAVE_UNISTD_H"
                    commandline += ' -DGIAC_GGB' // from old Makefile
                    commandline += ' -DTIMEOUT -DEMCC2 ' // from old config.h
                    commandline += " -Isrc/giac/headers -c $input -o $output"
                    println "Compiling: ${commandline}"
                    commandLine commandline.split()
                }
            }
        }
    }
}

task emccClean(type: Delete) {
    description 'Deletes .o files and linked giac*.js for cleaning up.'
    delete objDir, binaryJsDir
}


task emccCompileWasm {
    description 'Creates .o files for giac.js.'
    def list = []
    FileTree files = fileTree(dir: 'src/giac/cpp')
    files.visit { f ->
        if (f.name.endsWith('.cc')) {
            def emccCompileTask = 'emccCompileWasm' + "_" + f.name - '.cc' + 'Cc'
            list << emccCompileTask
        }
    }
    dependsOn list
}

task emccGiacJsWasm(dependsOn: 'emccCompileWasm') {
    description 'Links giac.js.'
    mustRunAfter 'emccCompileWasm'
    def output = binaryJsDir + "/giacggb.js"
    outputs.file output
    doLast {
        def list = []
        def linkerArgs = []
        def inputInclude = []
        FileTree files = fileTree(dir: objDir)
        files.visit { f ->
            def emccCompileTask = 'emccCompile_' + f.name - '.o' + 'Cc'
            inputInclude << f.name
            inputInclude << ('src/giac/cpp/' + f.name - '.o' + '.cc')
            list << emccCompileTask
            linkerArgs << objDir + "/${f.name}"
        }

        file(binaryJsDir).mkdirs()
        exec {
            linkerArgs << LlvmMpfrA // mpfr must precede gmp, see http://www.mpfr.org/faq.html, Q5
            linkerArgs << LlvmGmpA
            linkerArgs << '--js-library' << 'src/giac.js/js/time.js'

            linkerArgs << '-DGIAC_GGB'
            linkerArgs << '-o' << output
            // linkerArgs << "-s" << "DISABLE_EXCEPTION_CATCHING=0"
            linkerArgs << '-Oz' << '-v' << '-s' << "EXPORTED_FUNCTIONS=['_caseval']"
            linkerArgs << '-s' << 'EXTRA_EXPORTED_RUNTIME_METHODS=["cwrap"]'

            linkerArgs << '--memory-init-file' << '0'
            linkerArgs << '-s' << 'TOTAL_MEMORY=67108864' // consider increasing this if running out of memory on GB computations
            def linkerArgsString = linkerArgs.join(" ")
            println "Linking: ${emccCommand} ${linkerArgsString}"
            commandLine emccCommand
            args linkerArgs
        }
    }
}

task createGiacGgbJsWasm(dependsOn: 'emccGiacJsWasm', type: Copy) {
    description 'Creates the giacggb.js folder to store embeddable giac.js.'
    from 'src/giac.js'
    into binaryJsDir
    include ('ggb.html')
}

task createGiacWasmJs(dependsOn: 'createGiacGgbJsWasm') {
    description 'Creates WebAssembly version of Giac which can be embedded into GeoGebraWeb.'
    doLast {
        exec {
            commandLine "bash", "-c", "base64 -w0 giacggb.wasm > giacggb.wasm.b64"
            workingDir binaryJsDir
        }
        def wasmBase64 = file("${binaryJsDir}/giacggb.wasm.b64").text;
        file("${binaryJsDir}/giac.wasm.js").text = file("${binaryJsDir}/giacggb.js").text
                .replace('Module', '__ggb__giac').replace('"use asm";', '')
                .replace('giacggb.wasm', "data:application/octet-stream;base64,${wasmBase64}")
    }
}

// Using emsdk

task downloadEmsdk {
    description 'Downloads emscripten SDK and downloads it.'
    outputs.dir emsdkDir
    doLast {
        delete {
            delete emsdkDir
        }
        exec {
            commandLine 'git clone https://github.com/emscripten-core/emsdk.git'.split()
        }

        ant.symlink(resource: emsdkDir, link: "${emsdkDir}/emsdk-portable")
        mkdir("${emsdkDir}/emscripten")
        ant.symlink(resource: "${emsdkDir}/upstream/emscripten", link: "${emsdkDir}/emscripten/latest")
    }
}

task installEmsdk () {
    description 'Installs/updates the emscripten SDK.'
    mustRunAfter 'downloadEmsdk'
    doLast {
        exec {
            commandLine 'git pull'.split()
            workingDir emsdkRunDir
        }
        // FIXME: If already installed, this results in an error and stops.
        // Below this may not work with older emscripten versions.
        exec {
            commandLine "./emsdk install sdk-${emscriptenVersion}-64bit".split()
            workingDir emsdkRunDir
        }
    }
}

task activateEmsdk () {
    description 'Activates the emscripten SDK.'
    mustRunAfter 'installEmsdk'
    doLast {
        exec {
            commandLine "./emsdk activate sdk-${emscriptenVersion}-64bit".split()
            workingDir emsdkRunDir
        }
    }
}

task emConfigureGmp {
    description 'Configures GMP for the emscripten SDK.'
    doLast {
        exec {
            commandLine 'bash', '-c', "source $emsdkRunDir/emsdk_env.sh; ${emscriptenDir}/emconfigure $gmpSourceDir/configure --build=none --host=none --disable-assembly"
            workingDir gmpSourceDir
        }
    }
}

task emMakeGmp {
    description 'Makes GMP with the emscripten SDK.'
    doLast {
        exec {
            commandLine 'bash', '-c', "source $emsdkRunDir/emsdk_env.sh; ${emscriptenDir}/emmake make"
            workingDir gmpSourceDir
        }
    }
}

task emConfigureMpfr {
    description 'Configures MPFR for the emscripten SDK.'
    doLast {
        exec {
            commandLine 'bash', '-c', "source $emsdkRunDir/emsdk_env.sh; " +
                    "${emscriptenDir}/emconfigure $mpfrSourceDir/configure " +
                    "--build=none --host=none --disable-assembly " +
                    "--with-gmp-lib=$gmpSourceDir/.libs --with-gmp-include=$gmpSourceDir"
            workingDir mpfrSourceDir
        }
    }
}

task emMakeMpfr {
    description 'Makes MPFR with the emscripten SDK.'
    doLast {
        exec {
            commandLine 'bash', '-c', "source $emsdkRunDir/emsdk_env.sh; ${emscriptenDir}/emmake make"
            workingDir mpfrSourceDir
        }
    }
}

task androidCopyCrystaxSo (dependsOn: 'giac-android:copyCrystaxSo')

task androidAar (dependsOn: ['androidCopyCrystaxSo', 'androidCopyEabiLibjavagiacSo',
                             'androidCopyX86LibjavagiacSo', 'androidCopyX86_64LibjavagiacSo', 'androidCopyArm64LibjavagiacSo', 'giac-android:assemble']) {
    description 'Creates .aar package'
}

apply from: "deploy.gradle"
